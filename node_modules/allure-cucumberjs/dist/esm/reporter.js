var _excluded = ["resultsDir", "links", "labels"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { Formatter, World } from "@cucumber/cucumber";
import { AttachmentContentEncoding, TestStepResultStatus } from "@cucumber/messages";
import os from "node:os";
import { extname } from "node:path";
import process from "node:process";
import { ContentType, LabelName, Stage, Status } from "allure-js-commons";
import { getMessageAndTraceFromError } from "allure-js-commons/sdk";
import { ALLURE_RUNTIME_MESSAGE_CONTENT_TYPE, FileSystemWriter, MessageWriter, ReporterRuntime, applyLinkTemplate, createStepResult, getEnvironmentLabels, getWorstStepResultStatus, md5 } from "allure-js-commons/sdk/reporter";
import { AllureCucumberWorld } from "./legacy.js";
var {
  ALLURE_THREAD_NAME,
  ALLURE_TEST_MODE
} = process.env;
export default class AllureCucumberReporter extends Formatter {
  constructor(options) {
    super(options);
    _defineProperty(this, "afterHooks", {});
    _defineProperty(this, "beforeHooks", {});
    _defineProperty(this, "linksConfigs", {});
    _defineProperty(this, "labelsConfigs", []);
    _defineProperty(this, "allureRuntime", void 0);
    _defineProperty(this, "documentMap", new Map());
    _defineProperty(this, "scenarioMap", new Map());
    _defineProperty(this, "stepMap", new Map());
    _defineProperty(this, "testStepMap", new Map());
    _defineProperty(this, "pickleStepMap", new Map());
    _defineProperty(this, "pickleMap", new Map());
    _defineProperty(this, "testCaseMap", new Map());
    _defineProperty(this, "testCaseStartedMap", new Map());
    _defineProperty(this, "testResultUuids", new Map());
    _defineProperty(this, "scopeUuids", new Map());
    _defineProperty(this, "fixtureUuids", new Map());
    var _ref = options.parsedArgvOptions,
      {
        resultsDir = "./allure-results",
        links,
        labels
      } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded);
    this.allureRuntime = new ReporterRuntime(_objectSpread({
      writer: ALLURE_TEST_MODE ? new MessageWriter() : new FileSystemWriter({
        resultsDir
      }),
      links
    }, rest));
    this.linksConfigs = links || {};
    this.labelsConfigs = labels || [];
    options.eventBroadcaster.on("envelope", this.parseEnvelope.bind(this));
    this.beforeHooks = options.supportCodeLibrary.beforeTestCaseHookDefinitions.reduce((acc, hook) => Object.assign(acc, {
      [hook.id]: hook
    }), {});
    this.afterHooks = options.supportCodeLibrary.afterTestCaseHookDefinitions.reduce((acc, hook) => Object.assign(acc, {
      [hook.id]: hook
    }), {});
    // set AllureCucumberWorld for single thread mode
    if (options.supportCodeLibrary.World === World) {
      // @ts-ignore
      // noinspection JSConstantReassignment
      options.supportCodeLibrary.World = AllureCucumberWorld;
    }
  }
  get tagsIgnorePatterns() {
    var {
      labelsConfigs,
      linksConfigs
    } = this;
    var linkConfigEntries = Object.entries(linksConfigs).map(_ref2 => {
      var [, v] = _ref2;
      return v;
    });
    return [...labelsConfigs, ...linkConfigEntries].flatMap(_ref3 => {
      var {
        pattern
      } = _ref3;
      return pattern;
    });
  }
  parseEnvelope(envelope) {
    switch (true) {
      case !!envelope.gherkinDocument:
        this.onGherkinDocument(envelope.gherkinDocument);
        break;
      case !!envelope.pickle:
        this.onPickle(envelope.pickle);
        break;
      case !!envelope.testCase:
        this.onTestCase(envelope.testCase);
        break;
      case !!envelope.testCaseStarted:
        this.onTestCaseStarted(envelope.testCaseStarted);
        break;
      case !!envelope.testCaseFinished:
        this.onTestCaseFinished(envelope.testCaseFinished);
        break;
      case !!envelope.attachment:
        this.onAttachment(envelope.attachment);
        break;
      case !!envelope.testStepStarted:
        this.onTestStepStarted(envelope.testStepStarted);
        break;
      case !!envelope.testStepFinished:
        this.onTestStepFinished(envelope.testStepFinished);
        break;
      case !!envelope.testRunFinished:
        this.onTestRunFinished();
        break;
    }
  }
  parseTagsLabels(tags) {
    var labels = [];
    if (this.labelsConfigs.length === 0) {
      return labels;
    }
    this.labelsConfigs.forEach(matcher => {
      var matchedTags = tags.filter(tag => matcher.pattern.some(pattern => pattern.test(tag.name)));
      var matchedLabels = matchedTags.map(tag => {
        var tagValue = tag.name.replace(/^@\S+:/, "");
        return {
          name: matcher.name,
          value: tagValue
        };
      });
      labels.push(...matchedLabels);
    });
    return labels;
  }
  parsePickleTags(tags) {
    return tags.filter(tag => !this.tagsIgnorePatterns.some(pattern => pattern.test(tag.name))).map(tag => ({
      name: LabelName.TAG,
      value: tag.name
    }));
  }
  parseTagsLinks(tags) {
    var tagKeyRe = /^@\S+=/;
    var links = [];
    if (Object.keys(this.linksConfigs).length === 0) {
      return links;
    }
    Object.entries(this.linksConfigs).forEach(_ref4 => {
      var [type, matcher] = _ref4;
      var matchedTags = tags.filter(tag => matcher.pattern.some(pattern => pattern.test(tag.name)));
      var matchedLinks = matchedTags.map(tag => {
        var tagValue = tag.name.replace(tagKeyRe, "");
        return {
          url: applyLinkTemplate(matcher.urlTemplate, tagValue) || tagValue,
          type
        };
      });
      links.push(...matchedLinks);
    });
    return links;
  }
  parseStatus(stepResult) {
    var _stepResult$exception;
    var containsAssertionError = /assertion/i.test((stepResult === null || stepResult === void 0 || (_stepResult$exception = stepResult.exception) === null || _stepResult$exception === void 0 ? void 0 : _stepResult$exception.type) || "");
    switch (stepResult.status) {
      case TestStepResultStatus.FAILED:
        return containsAssertionError ? Status.FAILED : Status.BROKEN;
      case TestStepResultStatus.PASSED:
        return Status.PASSED;
      case TestStepResultStatus.SKIPPED:
      case TestStepResultStatus.PENDING:
        return Status.SKIPPED;
      default:
        return undefined;
    }
  }
  onRule(data) {
    var _data$children;
    (_data$children = data.children) === null || _data$children === void 0 || _data$children.forEach(c => {
      if (c.scenario) {
        this.onScenario(c.scenario);
      }
    });
  }
  onGherkinDocument(data) {
    var _data$feature;
    if (data.uri) {
      this.documentMap.set(data.uri, data);
    }
    (_data$feature = data.feature) === null || _data$feature === void 0 || (_data$feature = _data$feature.children) === null || _data$feature === void 0 || _data$feature.forEach(c => {
      if (c.rule) {
        this.onRule(c.rule);
      } else if (c.scenario) {
        this.onScenario(c.scenario);
      }
    });
  }
  onScenario(data) {
    this.scenarioMap.set(data.id, data);
    data.steps.forEach(step => this.stepMap.set(step.id, step));
  }
  onPickle(data) {
    this.pickleMap.set(data.id, data);
    data.steps.forEach(ps => this.pickleStepMap.set(ps.id, ps));
  }
  onTestCase(data) {
    this.testCaseMap.set(data.id, data);
    data.testSteps.forEach(ts => this.testStepMap.set(ts.id, ts));
  }
  onTestCaseStarted(data) {
    var _doc$feature, _doc$feature2, _doc$feature3;
    var testCase = this.testCaseMap.get(data.testCaseId);
    var pickle = this.pickleMap.get(testCase.pickleId);
    var doc = this.documentMap.get(pickle.uri);
    var [scenarioId] = pickle.astNodeIds;
    var scenario = this.scenarioMap.get(scenarioId);
    var fullName = "".concat(pickle.uri, "#").concat(pickle.name);
    var result = {
      name: pickle.name,
      description: ((scenario === null || scenario === void 0 ? void 0 : scenario.description) || (doc === null || doc === void 0 || (_doc$feature = doc.feature) === null || _doc$feature === void 0 ? void 0 : _doc$feature.description) || "").trim(),
      labels: [],
      links: [],
      testCaseId: md5(fullName),
      start: data.timestamp.nanos / 1000,
      fullName
    };
    result.labels.push(...getEnvironmentLabels());
    result.labels.push({
      name: LabelName.HOST,
      value: os.hostname()
    }, {
      name: LabelName.LANGUAGE,
      value: "javascript"
    }, {
      name: LabelName.FRAMEWORK,
      value: "cucumberjs"
    }, {
      name: LabelName.THREAD,
      value: data.workerId || ALLURE_THREAD_NAME || process.pid.toString()
    });
    if (doc !== null && doc !== void 0 && doc.feature) {
      result.labels.push({
        name: LabelName.FEATURE,
        value: doc.feature.name
      });
    }
    var pickleLabels = this.parsePickleTags(pickle.tags || []);
    var featureLabels = this.parseTagsLabels((doc === null || doc === void 0 || (_doc$feature2 = doc.feature) === null || _doc$feature2 === void 0 ? void 0 : _doc$feature2.tags) || []);
    var featureLinks = this.parseTagsLinks((doc === null || doc === void 0 || (_doc$feature3 = doc.feature) === null || _doc$feature3 === void 0 ? void 0 : _doc$feature3.tags) || []);
    var scenarioLabels = this.parseTagsLabels((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
    var scenarioLinks = this.parseTagsLinks((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || []);
    result.labels.push(...featureLabels, ...scenarioLabels, ...pickleLabels);
    result.links.push(...featureLinks, ...scenarioLinks);
    var scopeUuid = this.allureRuntime.startScope();
    this.scopeUuids.set(data.id, scopeUuid);
    var testUuid = this.allureRuntime.startTest(result, [scopeUuid]);
    this.testResultUuids.set(data.id, testUuid);
    this.testCaseStartedMap.set(data.id, data);
    if (!(scenario !== null && scenario !== void 0 && scenario.examples)) {
      return;
    }
    scenario.examples.forEach(example => {
      var _example$tableHeader;
      var csvDataTableHeader = (example === null || example === void 0 || (_example$tableHeader = example.tableHeader) === null || _example$tableHeader === void 0 ? void 0 : _example$tableHeader.cells.map(cell => cell.value).join(",")) || "";
      var csvDataTableBody = (example === null || example === void 0 ? void 0 : example.tableBody.map(row => row.cells.map(cell => cell.value).join(",")).join("\n")) || "";
      if (!csvDataTableHeader && !csvDataTableBody) {
        return;
      }
      var csvDataTable = "".concat(csvDataTableHeader, "\n").concat(csvDataTableBody, "\n");
      this.allureRuntime.writeAttachment(testUuid, null, "Examples", Buffer.from(csvDataTable, "utf-8"), {
        contentType: ContentType.CSV,
        fileExtension: ".csv"
      });
    });
  }
  onTestCaseFinished(data) {
    var testUuid = this.testResultUuids.get(data.testCaseStartedId);
    if (!testUuid) {
      return;
    }
    this.allureRuntime.updateTest(testUuid, result => {
      result.status = result.steps.length > 0 ? getWorstStepResultStatus(result.steps) : Status.PASSED;
      result.stage = Stage.FINISHED;
      if (result.status === undefined) {
        result.statusDetails = {
          message: "The test doesn't have an implementation."
        };
      }
    });
    this.allureRuntime.stopTest(testUuid, {
      stop: data.timestamp.nanos / 1000
    });
    this.allureRuntime.writeTest(testUuid);
    this.testResultUuids.delete(data.testCaseStartedId);
    var scopeUuid = this.scopeUuids.get(data.testCaseStartedId);
    if (scopeUuid) {
      this.allureRuntime.writeScope(scopeUuid);
      this.scopeUuids.delete(data.testCaseStartedId);
    }
  }
  onTestStepStarted(data) {
    var _stepPickle$argument;
    var testUuid = this.testResultUuids.get(data.testCaseStartedId);
    var step = this.testStepMap.get(data.testStepId);
    if (step.hookId) {
      var scopeUuid = this.scopeUuids.get(data.testCaseStartedId);
      if (!scopeUuid) {
        return;
      }
      var beforeHook = step.hookId && this.beforeHooks[step.hookId];
      var afterHook = step.hookId && this.afterHooks[step.hookId];
      var type = beforeHook ? "before" : afterHook ? "after" : undefined;
      if (!type) {
        return;
      }
      var name = beforeHook ? beforeHook.name : afterHook ? afterHook.name : "hook";
      if (name === "ALLURE_FIXTURE_IGNORE") {
        return;
      }
      var fixtureUuid = this.allureRuntime.startFixture(scopeUuid, type, {
        name,
        stage: Stage.RUNNING,
        start: data.timestamp.nanos / 1000
      });
      if (fixtureUuid) {
        this.fixtureUuids.set(data.testCaseStartedId, fixtureUuid);
      }
      return;
    }
    if (!step.pickleStepId) {
      return;
    }
    var stepPickle = this.pickleStepMap.get(step.pickleStepId);
    if (!stepPickle) {
      return;
    }
    var stepKeyword = stepPickle.astNodeIds.map(astNodeId => this.stepMap.get(astNodeId)).map(stepAstNode => stepAstNode === null || stepAstNode === void 0 ? void 0 : stepAstNode.keyword).find(keyword => keyword !== undefined) || "";
    var stepUuid = this.allureRuntime.startStep(testUuid, undefined, _objectSpread(_objectSpread({}, createStepResult()), {}, {
      name: "".concat(stepKeyword).concat(stepPickle.text),
      start: data.timestamp.nanos / 1000
    }));
    if (!((_stepPickle$argument = stepPickle.argument) !== null && _stepPickle$argument !== void 0 && _stepPickle$argument.dataTable)) {
      return;
    }
    var csvDataTable = stepPickle.argument.dataTable.rows.reduce((acc, row) => "".concat(acc + row.cells.map(cell => cell.value).join(","), "\n"), "");
    this.allureRuntime.writeAttachment(testUuid, stepUuid, "Data table", Buffer.from(csvDataTable, "utf-8"), {
      contentType: ContentType.CSV,
      fileExtension: ".csv"
    });
  }
  onTestStepFinished(data) {
    var step = this.testStepMap.get(data.testStepId);
    if (!step) {
      return;
    }
    var status = this.parseStatus(data.testStepResult);
    var stage = status !== Status.SKIPPED ? Stage.FINISHED : Stage.PENDING;
    if (step.hookId) {
      var fixtureUuid = this.fixtureUuids.get(data.testCaseStartedId);
      if (!fixtureUuid) {
        return;
      }
      this.allureRuntime.updateFixture(fixtureUuid, r => {
        r.stage = stage;
        r.status = status;
        if (data.testStepResult.exception) {
          r.statusDetails = getMessageAndTraceFromError({
            message: data.testStepResult.message,
            stack: data.testStepResult.exception.stackTrace
          });
        }
      });
      this.allureRuntime.stopFixture(fixtureUuid, {
        stop: data.timestamp.nanos / 1000
      });
      this.fixtureUuids.delete(data.testCaseStartedId);
      return;
    }
    var testUuid = this.testResultUuids.get(data.testCaseStartedId);
    var currentStep = this.allureRuntime.currentStep(testUuid);
    if (!currentStep) {
      return;
    }
    this.allureRuntime.updateStep(currentStep, r => {
      r.status = status;
      r.stage = stage;
      if (status === undefined) {
        r.statusDetails = {
          message: "The step doesn't have an implementation."
        };
        return;
      }
      if (data.testStepResult.exception) {
        r.statusDetails = {
          message: data.testStepResult.message,
          trace: data.testStepResult.exception.stackTrace
        };
      }
    });
    this.allureRuntime.stopStep(currentStep, {
      stop: data.timestamp.nanos / 1000
    });
  }
  onAttachment(message) {
    var _message$fileName;
    if (!message.testCaseStartedId) {
      return;
    }
    var fixtureUuid = this.fixtureUuids.get(message.testCaseStartedId);
    var testUuid = this.testResultUuids.get(message.testCaseStartedId);
    var rootUuid = fixtureUuid !== null && fixtureUuid !== void 0 ? fixtureUuid : testUuid;
    if (!rootUuid) {
      return;
    }
    if (message.mediaType === "application/vnd.allure.skipcucumber+json") {
      if (testUuid) {
        this.allureRuntime.updateTest(testUuid, result => {
          result.labels.push({
            name: "ALLURE_TESTPLAN_SKIP",
            value: "true"
          });
        });
      }
      return;
    }
    if (message.mediaType === ALLURE_RUNTIME_MESSAGE_CONTENT_TYPE) {
      var parsedMessage = JSON.parse(message.body);

      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.allureRuntime.applyRuntimeMessages(rootUuid, Array.isArray(parsedMessage) ? parsedMessage : [parsedMessage]);
      return;
    }
    var encoding = message.contentEncoding === AttachmentContentEncoding.BASE64 ? "base64" : "utf-8";
    this.allureRuntime.applyRuntimeMessages(rootUuid, [{
      type: "attachment_content",
      data: {
        name: (_message$fileName = message.fileName) !== null && _message$fileName !== void 0 ? _message$fileName : "Attachment",
        content: Buffer.from(message.body, encoding).toString("base64"),
        encoding: "base64",
        contentType: message.mediaType,
        fileExtension: message.fileName ? extname(message.fileName) : undefined,
        wrapInStep: true
      }
    }]);
  }
  onTestRunFinished() {
    this.allureRuntime.writeCategoriesDefinitions();
    this.allureRuntime.writeEnvironmentInfo();
  }
}
//# sourceMappingURL=reporter.js.map